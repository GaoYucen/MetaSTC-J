<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MetaSTC-J Model Architecture (TKDE Style)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Times New Roman', Times, serif; /* Academic standard */
            background-color: #ffffff;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #diagram {
            background-color: #ffffff;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .label-text {
            font-family: 'Arial', sans-serif; /* Sans-serif for labels often looks cleaner in diagrams */
            font-size: 12px;
            fill: #333;
        }
        .title-text {
            font-family: 'Times New Roman', serif;
            font-weight: bold;
            font-size: 16px;
            fill: #000;
        }
        .math-text {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        .arrow-head {
            fill: #555;
        }
        .dashed-box {
            fill: none;
            stroke: #888;
            stroke-width: 1.5;
            stroke-dasharray: 5, 5;
        }
    </style>
</head>
<body>
    <div id="diagram"></div>

    <script>
        // --- Configuration ---
        const width = 1200;
        const height = 700;
        const svg = d3.select("#diagram")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`);

        // Define arrow markers
        svg.append("defs").selectAll("marker")
            .data(["arrow", "arrow-blue", "arrow-red"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", d => d === "arrow-blue" ? "#1976D2" : (d === "arrow-red" ? "#D32F2F" : "#555"));

        // --- Helper Functions ---
        function drawBox(x, y, w, h, text, color, strokeColor = "#333", textColor = "#000") {
            const g = svg.append("g");
            g.append("rect")
                .attr("x", x)
                .attr("y", y)
                .attr("width", w)
                .attr("height", h)
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("fill", color)
                .attr("stroke", strokeColor)
                .attr("stroke-width", 1.5);
            
            // Handle multi-line text
            const lines = text.split("\n");
            lines.forEach((line, i) => {
                g.append("text")
                    .attr("x", x + w / 2)
                    .attr("y", y + h / 2 + (i - (lines.length - 1) / 2) * 15 + 4)
                    .attr("text-anchor", "middle")
                    .attr("class", "label-text")
                    .style("fill", textColor)
                    .style("font-weight", "bold")
                    .text(line);
            });
            return {x: x + w/2, y: y + h/2, top: y, bottom: y + h, left: x, right: x + w};
        }

        function drawCylinder(x, y, w, h, text, color) {
            const g = svg.append("g");
            const ry = 10;
            
            // Body
            g.append("path")
                .attr("d", `M${x},${y+ry} v${h-2*ry} a${w/2},${ry} 0 0 0 ${w},0 v-${h-2*ry}`)
                .attr("fill", color)
                .attr("stroke", "#333")
                .attr("stroke-width", 1.5);
            
            // Bottom cap (hidden part)
            g.append("ellipse")
                .attr("cx", x + w/2)
                .attr("cy", y + h - ry)
                .attr("rx", w/2)
                .attr("ry", ry)
                .attr("fill", color)
                .attr("stroke", "#333")
                .attr("stroke-width", 1.5);

            // Top cap
            g.append("ellipse")
                .attr("cx", x + w/2)
                .attr("cy", y + ry)
                .attr("rx", w/2)
                .attr("ry", ry)
                .attr("fill", "#fff")
                .attr("stroke", "#333")
                .attr("stroke-width", 1.5);

            g.append("text")
                .attr("x", x + w / 2)
                .attr("y", y + h / 2 + 5)
                .attr("text-anchor", "middle")
                .attr("class", "label-text")
                .style("font-weight", "bold")
                .text(text);
                
            return {x: x + w/2, y: y + h/2, top: y, bottom: y + h, left: x, right: x + w};
        }

        function drawArrow(x1, y1, x2, y2, color="#555", type="arrow") {
            svg.append("line")
                .attr("x1", x1)
                .attr("y1", y1)
                .attr("x2", x2)
                .attr("y2", y2)
                .attr("stroke", color)
                .attr("stroke-width", 2)
                .attr("marker-end", `url(#${type})`);
        }

        function drawCurvedArrow(x1, y1, x2, y2, controlX, controlY, color="#555", type="arrow") {
            const path = d3.path();
            path.moveTo(x1, y1);
            path.quadraticCurveTo(controlX, controlY, x2, y2);
            svg.append("path")
                .attr("d", path.toString())
                .attr("fill", "none")
                .attr("stroke", color)
                .attr("stroke-width", 2)
                .attr("marker-end", `url(#${type})`);
        }

        function drawMath(x, y, text, size=14, color="#000") {
            svg.append("text")
                .attr("x", x)
                .attr("y", y)
                .attr("class", "math-text")
                .style("font-size", size + "px")
                .style("fill", color)
                .text(text);
        }

        // --- Layout & Drawing ---

        // === Step 1: Feature Extraction (Left) ===
        svg.append("rect").attr("x", 30).attr("y", 50).attr("width", 280).attr("height", 600).attr("class", "dashed-box").attr("rx", 10);
        svg.append("text").attr("x", 170).attr("y", 40).attr("text-anchor", "middle").attr("class", "title-text").text("Step 1: Spatio-Temporal Feature Extraction");

        const inputG = drawBox(80, 80, 180, 50, "Road Network G(V,E)\nTraffic Flow Xt", "#E3F2FD", "#1565C0");
        
        // Branches
        const tFeat = drawBox(50, 180, 110, 60, "Traffic2Vec\n(Time)", "#FFF3E0", "#EF6C00");
        const sFeat = drawBox(180, 180, 110, 60, "Embedding\n(Space)", "#E8F5E9", "#2E7D32");

        drawArrow(inputG.x, inputG.bottom, tFeat.x, tFeat.top);
        drawArrow(inputG.x, inputG.bottom, sFeat.x, sFeat.top);

        // === Step 2: Gating & Clustering (Middle-Left) ===
        svg.append("rect").attr("x", 330).attr("y", 50).attr("width", 250).attr("height", 600).attr("class", "dashed-box").attr("rx", 10);
        svg.append("text").attr("x", 455).attr("y", 40).attr("text-anchor", "middle").attr("class", "title-text").text("Step 2: Gating & Clustering");

        // Gating Unit
        const gating = drawBox(380, 180, 150, 60, "Gating Unit\n(Sigmoid Fusion)", "#F3E5F5", "#7B1FA2");
        
        drawArrow(tFeat.right, tFeat.y, gating.left, gating.y);
        drawArrow(sFeat.right, sFeat.y, gating.left, gating.y);
        
        drawMath(400, 170, "ht");
        drawMath(400, 260, "hs");

        // Vector h
        const vecH = drawBox(405, 280, 100, 40, "Vector h", "#E0E0E0");
        drawArrow(gating.x, gating.bottom, vecH.x, vecH.top);

        // K-Means
        const kmeans = drawBox(380, 360, 150, 50, "K-Means++", "#B2EBF2", "#0097A7");
        drawArrow(vecH.x, vecH.bottom, kmeans.x, kmeans.top);

        // Clusters
        const c1 = drawBox(350, 450, 60, 40, "C1", "#B3E5FC");
        const c2 = drawBox(425, 450, 60, 40, "C2", "#B3E5FC");
        const ck = drawBox(500, 450, 60, 40, "Ck", "#B3E5FC");
        
        drawArrow(kmeans.x, kmeans.bottom, c1.x, c1.top);
        drawArrow(kmeans.x, kmeans.bottom, c2.x, c2.top);
        drawArrow(kmeans.x, kmeans.bottom, ck.x, ck.top);

        // === Step 3: Cluster-aware Memory Unit (Right - The Core) ===
        svg.append("rect").attr("x", 600).attr("y", 50).attr("width", 570).attr("height", 600).attr("class", "dashed-box").attr("rx", 10).style("stroke", "#D32F2F");
        svg.append("text").attr("x", 885).attr("y", 40).attr("text-anchor", "middle").attr("class", "title-text").style("fill", "#D32F2F").text("Step 3: Cluster-aware Memory Unit (Novelty)");

        // Memory Matrix
        const memory = drawCylinder(650, 100, 120, 150, "Memory Mc", "#FFCCBC");
        
        // Centroids
        const centroids = drawBox(650, 300, 120, 40, "Centroids pk", "#FFECB3", "#FFA000");
        
        // Similarity Calculation
        const similarity = drawBox(850, 280, 140, 60, "Similarity (a)\nSoftmax(Dist)", "#FFF9C4", "#FBC02D");
        
        // Connection from h (Step 2) to Similarity
        drawCurvedArrow(vecH.right, vecH.y, similarity.left, similarity.y, 600, 300, "#555");
        drawMath(620, 290, "h");

        drawArrow(centroids.right, centroids.y, similarity.left, similarity.y);

        // Gates
        const resetGate = drawBox(820, 120, 80, 50, "Reset\nGate (rt)", "#C8E6C9", "#388E3C");
        const updateGate = drawBox(920, 120, 80, 50, "Update\nGate (ut)", "#C8E6C9", "#388E3C");

        // Flow from Memory to Gates
        drawArrow(memory.right, memory.y - 20, resetGate.left, resetGate.y);
        drawArrow(memory.right, memory.y + 20, updateGate.left, updateGate.y);
        
        // Flow from Similarity to Gates
        drawArrow(similarity.x, similarity.top, resetGate.x, resetGate.bottom);
        drawArrow(similarity.x, similarity.top, updateGate.x, updateGate.bottom);

        // Hybrid Init
        const hybrid = drawBox(850, 450, 200, 80, "Hybrid Initialization\nθ_cluster", "#E1BEE7", "#8E24AA");
        
        // Inputs to Hybrid
        drawArrow(resetGate.x, resetGate.bottom, hybrid.top, hybrid.y - 40); // Simplified path
        drawArrow(updateGate.x, updateGate.bottom, hybrid.top, hybrid.y - 40);
        
        // Global Param
        const globalParam = drawBox(1080, 450, 80, 80, "Global\nΦ", "#CFD8DC", "#455A64");
        drawArrow(globalParam.left, globalParam.y, hybrid.right, hybrid.y);

        // Final Output
        const finalModel = drawBox(850, 580, 200, 50, "Task-Specific Model\nM(j,c)", "#C5CAE9", "#303F9F");
        drawArrow(hybrid.x, hybrid.bottom, finalModel.x, finalModel.top, "#D32F2F", "arrow-red");

        // Annotations
        drawMath(800, 200, "Retrieve Params");
        drawMath(950, 560, "Meta-Update");

    </script>
</body>
</html>